///////////////////////////////////////////////////////////////////////////////////
// TODO:: Add any needed includes
///////////////////////////////////////////////////////////////////////////////////
#include <random>
#include<iostream>
#include <future>
#include <thread>
#include <mutex>
#include <condition_variable>
// Include file and line numbers for memory leak detection for visual studio in debug mode
#if defined _MSC_VER && defined _DEBUG
	#include <crtdbg.h>
	#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
	#define ENABLE_LEAK_DETECTION() _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF)
#else
	#define ENABLE_LEAK_DETECTION()
#endif

class UniformRandInt
{
public:
	void Init(int min, int max)
	{
		// Seed our random number generator with a non-deterministic random value. If no such capabilities exist then
		//   the number will be pulled from a pseudo random number generator.
		randEngine.seed(randDevice());

		// We want to generate values in the range of [min, max] (inclusive) with a uniform distribution.
		distro = std::uniform_int_distribution<int>(min, max);
	}

	int operator()()
	{
		return distro(randEngine);
	}

private:
	std::random_device randDevice;
	std::mt19937 randEngine;
	std::uniform_int_distribution<int> distro;
};

struct ThreadStruct
{
	int id;									// thread number
	UniformRandInt myRand;					// random number generator for this thread
	
	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Any new data to pass to thread should be put here
	///////////////////////////////////////////////////////////////////////////////////	
	bool* pointerflag;
	int* pointerblank;
	std::condition_variable* pointerCon_Var;
	std::mutex* mutex1;
	std::mutex* flagmutex;
};

///////////////////////////////////////////////////////////////////////////////////
// Prompts the user to press enter and waits for user input
///////////////////////////////////////////////////////////////////////////////////
void Pause()
{
	printf("Press enter to continue\n");
	getchar();
}

////////////////////////////////////////////////////////////////////////////////////
// TODO:: Create a function to process (in this case just print) the 'work' 
//   generated by the Joinable and Detached threads that were created in main. The 
//   purpose of this function is to delay the printing of 'work' until it's been generated. 
//   You must also print out the thread ID along with the work value.
//
// Note: You are required to use a std::promise to implement this logic.
////////////////////////////////////////////////////////////////////////////////////
void workProcess(std::future<int> future_int, int id) {
	future_int.wait();
	if (id % 2 == 0)
		printf("\n MATCHME: Joinable Thread %d returned %d \n\n", id, future_int._Get_value());
	else 
		printf("\n MATCHME: Detached Thread %d returned %d \n\n", id, future_int._Get_value());
	
}

///////////////////////////////////////////////////////////////////////////////////
// Entry point for joinable threads. 
//
// Arguments:
//   threadData - Pointer to the thread specific data
///////////////////////////////////////////////////////////////////////////////////
void JoinableThreadEntrypoint(ThreadStruct *threadData)
{
	////////////////////////////////////////////////////////////////////////////////////
	// TODO:: Create a joinable thread to print the value of 'work' once it's generated.
	//   The printer (or "process work") thread MUST be created before 'work' is initialized and it must not
	//   print until 'work' has been generated by this thread. 
	//
	// Note: You are required to use a std::promise to implement the printing logic.
	////////////////////////////////////////////////////////////////////////////////////
	std::promise<int> joinPromise;
	std::future<int> joinFuture = joinPromise.get_future();
	std::thread JoinablePrinterThread(workProcess, std::move(joinFuture), threadData->id);

	int workLimit = (threadData->id + 1) + (threadData->myRand());
	int work = 0;

	// Performs some arbitrary amount of work.
	printf("START: Joinable Thread %d, starting limit = %d\n", threadData->id, workLimit);
	for (int i = 0; i < workLimit; i += (threadData->id + 1)) 
	{ 
		work++;
	}
	printf("FINISH: Joinable thread %d, finished with value %d\n", threadData->id, work);

	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: The 'work' has been generated and the printing thread should be waiting
	//   on the promised work to be set. Set it now so the printing thread can resume.
	///////////////////////////////////////////////////////////////////////////////////
	joinPromise.set_value(work);
	JoinablePrinterThread.join();
}

///////////////////////////////////////////////////////////////////////////////////
// Entry point for detached threads. 
//
// Arguments:
//   threadData - Pointer to the thread specific data
///////////////////////////////////////////////////////////////////////////////////
void DetachedThreadEntrypoint(ThreadStruct *threadData)
{
	////////////////////////////////////////////////////////////////////////////////////
	// TODO:: Create a joinable thread to print the value of 'work' once it's generated.
	//   The printer thread MUST be created before 'work' is initialized and it must not
	//   print until 'work' has been generated by this thread. 
	//
	// Note: You are required to use a std::promise to implement the printing logic.
	////////////////////////////////////////////////////////////////////////////////////
	std::promise<int> joinPromise;
	std::future<int> joinFuture = joinPromise.get_future();
	std::thread JoinablePrinterThread(workProcess, std::move(joinFuture), threadData->id);

	int workLimit = (threadData->id + 1) + (threadData->myRand());
	int work = 0;

	printf("START: Detached Thread %d, starting limit = %d\n", threadData->id, workLimit);
	
	while(true)
	{ 
		////////////////////////////////////////////////////////////////////////////////
		// TODO:: Break out of the work loop in a thread safe way.
		//		  (HINT: thread safe means that only ONE thread should be check or modifying
		//		   shared data at a time)
		///////////////////////////////////////////////////////////////////////////////////
		(*threadData->flagmutex).lock();
		if (!(*threadData->pointerflag)) {
			(*threadData->flagmutex).unlock();
			break;
		}
		(*threadData->flagmutex).unlock();

		// Performs some arbitrary amount of work.
		for (int i = 0; i < workLimit; i += (threadData->id + 1)) 
		{ 
			work++;
		}
	}
	printf("FINISH: Detached thread %d, finished with value %d\n", threadData->id, work);

	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Set the std::promise's value and wait for the printer thread to finish.
	///////////////////////////////////////////////////////////////////////////////////
	joinPromise.set_value(work);
	JoinablePrinterThread.join();

	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Let main know there's one less thread running.
	///////////////////////////////////////////////////////////////////////////////////
	(*threadData->mutex1).lock();
	(*threadData->pointerblank)++;
	(*threadData->mutex1).unlock();
	(*threadData->pointerCon_Var).notify_one();
}

int main(int argc, char **argv)
{
	ENABLE_LEAK_DETECTION();

	if (argc != 2)
	{
		fprintf(stderr, "Usage: ThreadTypes threadCount\n\n");
		fprintf(stderr, "Arguments:\n");
		fprintf(stderr, "    threadCount                  Number of joinable and detached threads to    \n");
		fprintf(stderr, "                                 create.                                       \n");
		Pause();
		return 1;
	}

	int totalThreadCount = 2 * atoi(argv[1]);
	
	if(totalThreadCount < 0)
	{
		fprintf(stderr, "Error: All arguments must be positive integer values.\n");
		Pause();
		return 1;
	}

	///////////////////////////////////////////////////////////////////////////////////	
	// TODO:: Declare your variables here
	///////////////////////////////////////////////////////////////////////////////////
	bool flag = true;
	int blank = 0;
	std::condition_variable con_var;
	std::vector<std::thread> threads;
	std::mutex threadmutex;
	std::mutex flagmutex;

	ThreadStruct *perThreadData = new ThreadStruct[totalThreadCount];
	printf("Main thread starting %d thread(s)\n", totalThreadCount);
	
	for(int i = totalThreadCount - 1; i >= 0; i--)
	{		
		perThreadData[i].id = i;
		perThreadData[i].myRand.Init(0, 100);

		///////////////////////////////////////////////////////////////////////////////////
		// TODO:: Initialize any additional per-thread data and create the threads. If 'i' is
		//   odd then the thread must execute the 'detached' logic in a detached state, otherwise
		//   the thread must execute the 'joinable' logic.
		///////////////////////////////////////////////////////////////////////////////////
		if (i % 2 == 0) // Joinable threads
			threads.push_back(std::thread(JoinableThreadEntrypoint, &perThreadData[i]));
		else {
			//Detached threads
			perThreadData[i].pointerflag = &flag;
			perThreadData[i].pointerblank = &blank;
			perThreadData[i].pointerCon_Var = &con_var;
			perThreadData[i].mutex1 = &threadmutex;
			perThreadData[i].flagmutex = &flagmutex;
			std::thread detachedThread(DetachedThreadEntrypoint, &perThreadData[i]);
			detachedThread.detach();
		}
	}

	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Wait for all joinable threads to complete
	///////////////////////////////////////////////////////////////////////////////////	
	for (int i = 0; i < totalThreadCount / 2; i++)
		threads[i].join();
	
	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: let detached threads know they need to shut down using the flag you
	//   created in the thread structure. You may only set the flag once here (you should
	//   not have more than one flag) and it must be in a thread safe manner.
	///////////////////////////////////////////////////////////////////////////////////
	flagmutex.lock();
	flag = false;
	for (int i = totalThreadCount; i >= 0; i--)
		if (i % 2 == 1)
			perThreadData[i].pointerflag = &flag;
	flagmutex.unlock();
	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Wait for all detached threads to finish without using a busy-wait loop.
	//   You must wait for the number of threads to change before checking again to avoid
	//   wasting CPU cycles. 
	//   (HINT: Remember there is a specific object that can Wait for a Condition)
	///////////////////////////////////////////////////////////////////////////////////
	std::unique_lock<std::mutex> lock(threadmutex);
	con_var.wait(lock, [&]() {return blank == (totalThreadCount / 2); });
	///////////////////////////////////////////////////////////////////////////////////
	// TODO:: Cleanup
	///////////////////////////////////////////////////////////////////////////////////
	delete[] perThreadData;
	Pause();
	
	return 0;
}
